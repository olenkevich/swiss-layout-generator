<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Design Layout Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --canvas-w: 1280px; --canvas-h: 720px;
    --gap: 8px; --bg:#fff; --ink:#111; --accent:#111;
    
    /* Typography System - Swiss/German Design Principles */
    --baseline: 8px;
    --type-scale-ratio: 1.618; /* Golden ratio */
    
    /* Font Sizes - Modular Scale */
    --type-logo: 48px;      /* 48px - Strong brand presence */
    --type-header: 64px;    /* 64px - Primary hierarchy */
    --type-lead: 40px;      /* 40px - Secondary hierarchy */
    --type-subheader: 32px; /* 32px - Tertiary hierarchy */
    --type-body: 24px;      /* 24px - Main body text */
    --type-small: 18px;     /* 18px - Supporting text */
    --type-caption: 14px;   /* 14px - Fine print */
    
    /* Line Heights - Optical Corrections */
    --lh-tight: 1.1;        /* For large display text */
    --lh-normal: 1.4;       /* For body text */
    --lh-loose: 1.5;        /* For small text */
    
    /* Letter Spacing - Swiss Precision */
    --ls-tight: -0.02em;    /* Condensed for headers */
    --ls-normal: 0;         /* Natural for body */
    --ls-loose: 0.05em;     /* Expanded for small text */
    
    /* Font Weights - Hierarchy Support */
    --fw-light: 300;
    --fw-regular: 400;
    --fw-medium: 500;
    --fw-bold: 600;
    
    /* Spacing Scale - Baseline Grid */
    --space-xs: calc(var(--baseline) * 1);  /* 8px */
    --space-sm: calc(var(--baseline) * 2);  /* 16px */
    --space-md: calc(var(--baseline) * 3);  /* 24px */
    --space-lg: calc(var(--baseline) * 4);  /* 32px */
    --space-xl: calc(var(--baseline) * 5);  /* 40px */
    --space-xxl: calc(var(--baseline) * 6); /* 48px */
  }

  /* App split: left controls, right preview */
  html, body { height:100%; margin:0; font-family: Helvetica, Arial, sans-serif; }
  .app { height:100%; display:flex; }

  /* Left sidebar */
  .sidebar {
    width: 280px;
    background:#f9f9f9;
    border-right:1px solid #ccc;
    padding:12px;
    box-sizing:border-box;
    display:flex; flex-direction:column; gap:10px;
  }
  .sidebar h3 { margin:8px 0 4px; font-size:14px }
  .sidebar input[type=text], .sidebar select { width:100%; padding:6px; box-sizing:border-box; }
  .sidebar input[type=file] { width:100%; }
  .sidebar button { padding:6px; cursor:pointer; }
  .sidebar label { display:block; margin:4px 0; font-size:12px; }
  .sidebar input[type=color] { width:50px; height:30px; margin-left:8px; }
  
  /* Block list styles */
  #blockList { max-height: 200px; overflow-y: auto; }
  .block-item { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    padding: 4px 6px; 
    margin: 2px 0; 
    background: #fff; 
    border: 1px solid #ddd; 
    border-radius: 3px; 
    font-size: 11px;
  }
  .block-item .block-info { flex: 1; overflow: hidden; }
  .block-item .delete-btn { 
    background: #ff4444; 
    color: white; 
    border: none; 
    padding: 2px 6px; 
    border-radius: 2px; 
    cursor: pointer; 
    font-size: 10px;
  }

  /* Color palette styles */
  #colorPalette { margin: 8px 0; }
  .palette-colors {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin: 4px 0;
  }
  .color-swatch {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid #ddd;
    cursor: pointer;
    transition: transform 0.1s;
  }
  .color-swatch:hover { transform: scale(1.1); }
  
  #shuffleBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Right preview panel */
  .preview {
    flex:1;
    position:relative;          /* anchor for absolute #scaler */
    background:#eee;
    overflow:hidden;
    padding: 40px;
    box-sizing: border-box;
  }

  /* Absolutely centered scaler */
  #scaler{
    position:absolute;
    top:50%; left:50%;
    transform-origin: center center; /* scale around center */
  }

  /* Fixed-size canvas (true logical size) */
  #canvas{
    width: var(--canvas-w);
    height: var(--canvas-h);
    background: var(--bg);
    box-shadow: 0 6px 30px rgba(0,0,0,.15);
    padding: var(--gap);
    display:flex;
    overflow:hidden;
  }

  /* Layout engine - Swiss Grid System */
  .row, .col { 
    display: flex; 
    gap: var(--space-sm); /* 16px - optimal content spacing */
    flex: 1 1 0; 
    min-width: 0; 
    min-height: 0; 
  }
  
  .row { 
    align-items: baseline; /* TRUE typographic baseline alignment */
  }
  
  .col { 
    flex-direction: column; 
  }
  
  .leaf { 
    flex: 1 1 0; 
    min-width: 0; 
    min-height: 0; 
    padding: var(--space-md); /* 24px - generous content padding */
    overflow: hidden;
    /* Baseline alignment now handled by .row containers */
  }
  
  /* Swiss Typography Styles */
  .text { 
    width: 100%; 
    height: auto;
    word-break: keep-all; 
    overflow-wrap: normal; 
    color: var(--ink);
    text-align: left;
    /* True baseline alignment handled by .row containers */
  }
  
  .text[data-type="header"] { 
    color: var(--accent);
    font-weight: var(--fw-medium);     /* Medium for headers only */
  }
  
  .text[data-type="subheader"] {
    font-weight: var(--fw-regular);    /* Regular */
  }
  
  .text[data-type="body"] {
    font-weight: var(--fw-regular);    /* Regular */
  }
  
  .text[data-type="logo"] {
    color: var(--accent);
    font-weight: var(--fw-regular);    /* Regular */
    text-transform: uppercase;
    letter-spacing: var(--ls-loose);
  }
  
  .image { 
    width: 100%; 
    height: 100%; /* Restore full height */
    object-fit: cover; 
    display: block; 
    /* Baseline alignment handled by .row containers */
  }
  
  /* Legacy logo class - updated with Swiss principles */
  .logo { 
    font-weight: var(--fw-medium); 
    font-size: var(--type-logo); 
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: var(--ls-tight);
    /* True baseline alignment handled by .row containers */
  }
</style>
</head>
<body>
<div class="app">
  <!-- Left controls -->
  <div class="sidebar">
    <h3>Add Text Block</h3>
    <input id="textContent" type="text" placeholder="Enter text content">
    <select id="textType">
      <option value="header">Header</option>
      <option value="subheader">Subheader</option>
      <option value="body">Body Text</option>
      <option value="logo">Logo</option>
    </select>
    <button onclick="addTextBlock()">Add Text</button>

    <h3>Add Image</h3>
    <input id="imageFile" type="file" accept="image/*">
    <select id="imageSize">
      <option value="large">Large</option>
      <option value="small">Small</option>
    </select>
    <button onclick="addImageBlock()">Add Image</button>

    <h3>Current Blocks</h3>
    <div id="blockList"></div>

    <h3>Format</h3>
    <select id="format">
      <option value="16-9" selected>16:9</option>
      <option value="1-1">1:1</option>
      <option value="a4">A4 Portrait</option>
      <option value="a4landscape">A4 Landscape</option>
    </select>

    <h3>Colors</h3>
    <label>Background: <input id="bgColor" type="color" value="#ffffff"></label>
    <label>Text: <input id="textColor" type="color" value="#111111"></label>
    <label>Accent: <input id="accentColor" type="color" value="#111111"></label>
    <button onclick="applyColors()">Apply Colors</button>
    <button onclick="shuffleColors()" id="shuffleBtn" disabled>Shuffle Colors</button>
    <div id="colorPalette" style="display:none;"></div>

    <h3>Actions</h3>
    <button onclick="render()">Recompose</button>
    <button onclick="resetAll()">Reset All</button>
  </div>

  <!-- Right preview -->
  <div class="preview" id="preview">
    <div id="scaler">
      <div id="canvas"></div>
    </div>
  </div>
</div>

<script>
const root   = document.documentElement;
const canvas = document.getElementById("canvas");
const scaler = document.getElementById("scaler");
const preview= document.getElementById("preview");

let blocks = [
  {id: 'demo-header', type: 'header', content: 'Design Made Simple', hero: true, size: 'large'},
  {id: 'demo-body', type: 'body', content: 'Create stunning layouts with our intelligent design generator. Perfect for presentations, social media, and creative projects.', size: 'large'},
  {id: 'demo-subheader', type: 'subheader', content: 'Professional Results in Seconds', size: 'large'},
  {id: 'demo-logo', type: 'logo', content: 'STUDIO', size: 'large'},
  {id: 'demo-image', type: 'image', src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgdmlld0JveD0iMCAwIDQwMCAzMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iMzAwIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMF8xKSIvPgo8ZGVmcz4KPGXPYW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8wXzEiIHgxPSIwIiB5MT0iMCIgeDI9IjQwMCIgeTI9IjMwMCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjNjY2NkZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGNjZEQSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=', size: 'large'}
];

// Typography Scale - Swiss Design Hierarchy
const SCALE = { 
  header: 64,     // Primary headlines - strong presence
  subheader: 32,  // Secondary headlines - clear hierarchy  
  body: 24,       // Main text - optimal readability
  logo: 48,       // Brand identity - balanced prominence
  lead: 40,       // Introductory text - intermediate hierarchy
  small: 18,      // Supporting text - maintains legibility
  caption: 14     // Fine print - compact but readable
};

// Typography Properties - Swiss Simplicity (3 weights max)
const TYPE_PROPS = {
  header: { weight: 500, lineHeight: 1.1, letterSpacing: '-0.02em' },     // Medium for headers
  subheader: { weight: 400, lineHeight: 1.2, letterSpacing: '-0.01em' },  // Regular
  body: { weight: 400, lineHeight: 1.4, letterSpacing: '0' },             // Regular
  logo: { weight: 400, lineHeight: 1.1, letterSpacing: '-0.01em' },       // Regular
  lead: { weight: 400, lineHeight: 1.3, letterSpacing: '-0.005em' },      // Regular
  small: { weight: 400, lineHeight: 1.5, letterSpacing: '0.01em' },       // Regular
  caption: { weight: 400, lineHeight: 1.5, letterSpacing: '0.05em' }      // Regular
};

const BASELINE = 8;

let extractedPalette = [];
let colorCombinations = [];
let currentColorIndex = 0;

/* ---------- Controls ---------- */
function addTextBlock(){
  const content = document.getElementById("textContent").value;
  const type = document.getElementById("textType").value;
  
  if(!content.trim()) {
    alert('Please enter some text content');
    return;
  }
  
  const id = (crypto.randomUUID) ? crypto.randomUUID() : ("id-"+Math.random().toString(36).slice(2));
  const block = {
    id, 
    type, 
    content: content.trim(), 
    size: 'large'
  };
  
  if(type === 'header') block.hero = true;
  
  blocks.push(block);
  document.getElementById("textContent").value = '';
  updateBlockList();
  render();
}

function addImageBlock(){
  const file = document.getElementById("imageFile").files[0];
  const size = document.getElementById("imageSize").value;
  
  if(!file) {
    alert('Please select an image file');
    return;
  }
  
  const id = (crypto.randomUUID) ? crypto.randomUUID() : ("id-"+Math.random().toString(36).slice(2));
  const imageSrc = URL.createObjectURL(file);
  
  blocks.push({
    id, 
    type: 'image', 
    src: imageSrc, 
    size
  });
  
  document.getElementById("imageFile").value = '';
  updateBlockList();
  render();
  
  // Extract beautiful color palette from the uploaded image
  extractBeautifulPalette(imageSrc).then(palette => {
    extractedPalette = palette;
    colorCombinations = createBeautifulCombinations(palette);
    currentColorIndex = 0;
    
    console.log('Generated', colorCombinations.length, 'color combinations');
    displayColorPalette();
    if (colorCombinations.length > 0) {
      applyColorCombination(0);
      document.getElementById('shuffleBtn').disabled = false;
    }
  }).catch(err => {
    console.log('Color extraction failed:', err.message);
    resetColorSystem();
  });
}

function deleteBlock(blockId){
  blocks = blocks.filter(b => b.id !== blockId);
  updateBlockList();
  render();
}

function updateBlockList(){
  const listEl = document.getElementById('blockList');
  listEl.innerHTML = '';
  
  blocks.forEach(block => {
    const item = document.createElement('div');
    item.className = 'block-item';
    
    const info = document.createElement('div');
    info.className = 'block-info';
    
    let displayText = '';
    if(block.type === 'image') {
      displayText = `Image (${block.size})`;
    } else {
      const truncated = block.content.length > 20 ? 
        block.content.substring(0, 17) + '...' : 
        block.content;
      displayText = `${block.type}: ${truncated}`;
    }
    
    info.textContent = displayText;
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = 'Ã—';
    deleteBtn.onclick = () => deleteBlock(block.id);
    
    item.appendChild(info);
    item.appendChild(deleteBtn);
    listEl.appendChild(item);
  });
}

function resetAll(){ 
  blocks = []; 
  updateBlockList(); 
  render(); 
}

/* ---------- Render & Layout ---------- */
function render(){
  canvas.innerHTML = "";
  // Always show the canvas (even if no blocks) so preview is visible
  if(blocks.length===0){
    // empty canvas still scales and centers
    scaleToPreview();
    return;
  }
  const shuffled=[...blocks].sort(()=>Math.random()-0.5);
  const dir=getSmartDirection(blocks);
  const tree=subdivide(shuffled,dir);
  canvas.appendChild(renderNode(tree));
  requestAnimationFrame(()=>{ recalcAllText(); scaleToPreview(); });
}

// Smart direction selection based on content
function getSmartDirection(blocks) {
  const imageCount = blocks.filter(b => b.type === 'image').length;
  const textCount = blocks.filter(b => ['header', 'subheader', 'body'].includes(b.type)).length;
  const hasLogo = blocks.some(b => b.type === 'logo');
  
  // Text-heavy layouts work better in columns (vertical stacking)
  if (textCount > imageCount && textCount > 2) {
    return 'col';
  }
  
  // Image + text combinations work better in rows (horizontal layout)
  if (imageCount >= 1 && textCount >= 1) {
    return 'row';
  }
  
  // Multiple images create gallery-like arrangements in rows
  if (imageCount > 1) {
    return 'row';
  }
  
  // Default to column for simple layouts
  return 'col';
}

// Smart ratio selection based on content importance
function getSmartRatio(items, hasHero) {
  // Hero content gets prominent space (golden ratio)
  if (hasHero) {
    return 0.618; // Golden ratio for elegant hierarchy
  }
  
  // Check content types for intelligent sizing
  const hasImages = items.some(item => item.type === 'image');
  const hasHeaders = items.some(item => item.type === 'header');
  const textItems = items.filter(item => ['header', 'subheader', 'body'].includes(item.type));
  
  // Header + content combinations get clear hierarchy
  if (hasHeaders && items.length > 1) {
    return 0.67; // 2:1 ratio for clear but not extreme hierarchy
  }
  
  // Image-heavy layouts get balanced splits
  if (hasImages && items.length <= 3) {
    return 0.618; // Golden ratio for visual harmony
  }
  
  // Equal split for balanced democratic layouts
  return 0.5;
}

function subdivide(items,dir){
  if(items.length===1) return {kind:"leaf",item:items[0]};
  const hero=items.some(it=>it.hero);
  let ratio=getSmartRatio(items, hero);
  const sizeA=Math.max(1,Math.min(items.length-1,Math.round(items.length*ratio)));
  return {kind:"split",direction:dir,ratio,
    a:subdivide(items.slice(0,sizeA),toggle(dir)),
    b:subdivide(items.slice(sizeA),toggle(dir))};
}

function renderNode(node){
  if(node.kind==="leaf"){
    const el=document.createElement("div"); el.className="leaf";
    if(["header","subheader","body"].includes(node.item.type)){
      const t=document.createElement("div");
      t.className="text"; t.textContent=node.item.content; t.dataset.id=node.item.id;
      t.dataset.type=node.item.type;
      el.appendChild(t);
    }
    if(node.item.type==="image"){
      const img=document.createElement("img"); img.className="image"; img.src=node.item.src; el.appendChild(img);
    }
    if(node.item.type==="logo"){
      const t=document.createElement("div"); t.className="logo"; t.textContent=node.item.content; el.appendChild(t);
    }
    return el;
  }
  const wrap=document.createElement("div"); wrap.className=node.direction==="row"?"row":"col";
  const a=document.createElement("div"); a.className=node.direction==="row"?"col":"row"; a.style.flex=node.ratio;
  const b=document.createElement("div"); b.className=node.direction==="row"?"col":"row"; b.style.flex=1-node.ratio;
  a.appendChild(renderNode(node.a)); b.appendChild(renderNode(node.b));
  wrap.appendChild(a); wrap.appendChild(b); return wrap;
}

/* ---------- Swiss Typography System ---------- */
function fitText(container, el, item) {
  const maxW = container.offsetWidth;
  const maxH = container.offsetHeight;
  
  // Get base size and properties for this type
  let fontSize = SCALE[item.type] || SCALE.body;
  const props = TYPE_PROPS[item.type] || TYPE_PROPS.body;
  
  // Apply Swiss design principles
  const applyTypography = () => {
    el.style.fontSize = fontSize + 'px';
    el.style.fontWeight = props.weight;
    el.style.letterSpacing = props.letterSpacing;
    
    // Calculate line height with baseline grid alignment
    const rawLineHeight = fontSize * props.lineHeight;
    const baselineAlignedHeight = Math.max(
      BASELINE, 
      Math.round(rawLineHeight / BASELINE) * BASELINE
    );
    el.style.lineHeight = baselineAlignedHeight + 'px';
    
    // Optical corrections for different sizes
    if (fontSize >= 48) {
      // Large display text - tighter spacing
      el.style.letterSpacing = 'calc(' + props.letterSpacing + ' - 0.01em)';
    } else if (fontSize <= 18) {
      // Small text - looser spacing for legibility
      el.style.letterSpacing = 'calc(' + props.letterSpacing + ' + 0.02em)';
    }
  };
  
  applyTypography();
  
  // Swiss precision - maintain hierarchy while fitting
  const minSize = Math.max(12, fontSize * 0.6); // Never go below 60% or 12px
  let guard = 100;
  
  while (guard-- > 0 && 
         (el.scrollWidth > maxW || el.scrollHeight > maxH) && 
         fontSize > minSize) {
    fontSize = Math.max(minSize, fontSize - 1);
    applyTypography();
  }
  
  // Final baseline alignment check
  const computedHeight = parseFloat(el.style.lineHeight);
  if (computedHeight % BASELINE !== 0) {
    el.style.lineHeight = (Math.round(computedHeight / BASELINE) * BASELINE) + 'px';
  }
}
function recalcAllText(){
  canvas.querySelectorAll(".text").forEach(el=>{
    const block=blocks.find(b=>b.id===el.dataset.id);
    if(block) fitText(el.parentElement,el,block);
  });
}

/* ---------- Scaling (uses actual preview pane size) ---------- */
function scaleToPreview(){
  const vw = preview.clientWidth;     // width of the right pane
  const vh = preview.clientHeight;    // height of the right pane
  const cw = canvas.offsetWidth;      // logical canvas size
  const ch = canvas.offsetHeight;
  if(!vw || !vh || !cw || !ch) return;

  // Reserve 40px padding on all sides for scaling calculation
  const availableW = vw - 80;  // 40px on each side
  const availableH = vh - 80;  // 40px on each side
  
  const s = Math.min(availableW / cw, availableH / ch, 1); // only scale down
  scaler.style.width = cw + "px";
  scaler.style.height = ch + "px";
  scaler.style.transform = `translate(-50%, -50%) scale(${s})`;
}

/* ---------- Format chooser ---------- */
function setFormat(fmt){
  let w=1280,h=720;
  if(fmt==="1-1"){w=900;h=900;}
  if(fmt==="a4"){w=794;h=1123;}
  if(fmt==="a4landscape"){w=1123;h=794;}
  root.style.setProperty("--canvas-w", w+"px");
  root.style.setProperty("--canvas-h", h+"px");
  scaleToPreview();
}
document.getElementById("format").addEventListener("change", e=>setFormat(e.target.value));

/* ---------- Color Functions ---------- */
function applyColors() {
  const bg = document.getElementById('bgColor').value;
  const text = document.getElementById('textColor').value;
  const accent = document.getElementById('accentColor').value;
  root.style.setProperty('--bg', bg);
  root.style.setProperty('--ink', text);
  root.style.setProperty('--accent', accent);
}

function autoColors() {
  const firstImage = blocks.find(b => b.type === 'image');
  if (!firstImage) {
    alert('Add an image first to extract colors');
    return;
  }
  
  extractColorsFromImage(firstImage.src).then(colors => {
    const palette = createContrastPalette(colors);
    document.getElementById('bgColor').value = palette.bg;
    document.getElementById('textColor').value = palette.text;
    root.style.setProperty('--bg', palette.bg);
    root.style.setProperty('--ink', palette.text);
  }).catch(err => {
    console.error('Color extraction failed:', err);
    alert('Could not extract colors from image. Try a different image.');
  });
}

function extractBeautifulPalette(imageSrc) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Use good resolution for better color analysis
        const maxSize = 150;
        const scale = Math.min(maxSize / img.width, maxSize / img.height);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const rawColors = [];
        
        // Sample every 16th pixel for good coverage
        for (let i = 0; i < imageData.data.length; i += 64) {
          const r = imageData.data[i];
          const g = imageData.data[i + 1];
          const b = imageData.data[i + 2];
          const a = imageData.data[i + 3];
          
          if (a > 200) { // Only fully opaque pixels
            rawColors.push({r, g, b});
          }
        }
        
        if (rawColors.length === 0) {
          reject(new Error('No colors found in image'));
          return;
        }
        
        const beautifulPalette = createBeautifulPalette(rawColors);
        resolve(beautifulPalette);
        
      } catch (error) {
        reject(error);
      }
    };
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = imageSrc;
  });
}

function createBeautifulPalette(colors) {
  // Group colors by similarity and find the most interesting ones
  const colorClusters = {};
  
  colors.forEach(color => {
    // Group colors into clusters
    const hsl = rgbToHsl(color.r, color.g, color.b);
    const hueGroup = Math.round(hsl.h / 30) * 30; // 30-degree hue groups
    const satGroup = Math.round(hsl.s * 4) / 4; // 0, 0.25, 0.5, 0.75, 1
    const lumGroup = Math.round(hsl.l * 4) / 4; // 0, 0.25, 0.5, 0.75, 1
    
    const key = `${hueGroup}-${satGroup}-${lumGroup}`;
    
    if (!colorClusters[key]) {
      colorClusters[key] = {
        colors: [],
        avgHue: hsl.h,
        avgSat: hsl.s,
        avgLum: hsl.l,
        count: 0
      };
    }
    
    colorClusters[key].colors.push(color);
    colorClusters[key].count++;
  });
  
  // Select the most prominent and interesting colors
  const significantClusters = Object.values(colorClusters)
    .filter(cluster => cluster.count > colors.length * 0.01) // At least 1% of pixels
    .sort((a, b) => {
      // Prefer colorful over gray, and common over rare
      const aInterest = a.avgSat * 2 + (a.count / colors.length);
      const bInterest = b.avgSat * 2 + (b.count / colors.length);
      return bInterest - aInterest;
    })
    .slice(0, 8); // Take top 8 clusters
  
  // Convert back to RGB and create diverse palette
  const palette = [];
  
  significantClusters.forEach(cluster => {
    // Take the most representative color from each cluster
    const representative = cluster.colors.reduce((best, color) => {
      const hsl = rgbToHsl(color.r, color.g, color.b);
      const distance = Math.abs(hsl.h - cluster.avgHue) + 
                      Math.abs(hsl.s - cluster.avgSat) + 
                      Math.abs(hsl.l - cluster.avgLum);
      
      if (!best || distance < best.distance) {
        return {color, distance};
      }
      return best;
    }, null);
    
    if (representative) {
      palette.push(representative.color);
    }
  });
  
  // Ensure we have good variety - add complementary colors if needed
  if (palette.length < 4) {
    palette.push({r: 255, g: 255, b: 255}); // White
    palette.push({r: 50, g: 50, b: 50}); // Dark gray
  }
  
  return palette;
}

function createContrastPalette(colors) {
  return createHarmonicPalette(colors);
}

function createHarmonicPalette(colors) {
  // Get the most prominent colors from the image
  const colorCounts = {};
  colors.forEach(color => {
    const key = `${Math.floor(color.r/30)*30},${Math.floor(color.g/30)*30},${Math.floor(color.b/30)*30}`;
    colorCounts[key] = (colorCounts[key] || 0) + 1;
  });
  
  // Sort by frequency and get top colors
  const sortedColors = Object.entries(colorCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([key, count]) => {
      const [r, g, b] = key.split(',').map(Number);
      return {r, g, b};
    });
  
  // Create beautiful dark+light pairs from extracted colors
  const pairs = [];
  
  sortedColors.forEach(color => {
    const hsl = rgbToHsl(color.r, color.g, color.b);
    
    // Create light version (background)
    const lightBg = hslToRgb(hsl.h, Math.max(0.1, hsl.s * 0.2), Math.max(0.85, 0.95));
    
    // Create dark version (text) 
    const darkText = hslToRgb(hsl.h, Math.min(0.8, hsl.s * 1.2), Math.min(0.25, hsl.l * 0.6));
    
    pairs.push({
      bg: rgbToHex(lightBg.r, lightBg.g, lightBg.b),
      text: rgbToHex(darkText.r, darkText.g, darkText.b)
    });
    
    // Also create inverted pair if the original color works as background
    if (hsl.l > 0.7) {
      const tintedBg = hslToRgb(hsl.h, Math.max(0.15, hsl.s * 0.4), Math.max(0.88, hsl.l));
      pairs.push({
        bg: rgbToHex(tintedBg.r, tintedBg.g, tintedBg.b),
        text: rgbToHex(darkText.r, darkText.g, darkText.b)
      });
    }
  });
  
  // Return a random pair for shuffling
  return pairs[Math.floor(Math.random() * pairs.length)];
}

function getLuminance(r, g, b) {
  const [rs, gs, bs] = [r, g, b].map(c => {
    c = c / 255;
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  });
  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

function getContrastRatio(color1, color2) {
  const lum1 = getLuminance(color1.r, color1.g, color1.b);
  const lum2 = getLuminance(color2.r, color2.g, color2.b);
  const lighter = Math.max(lum1, lum2);
  const darker = Math.min(lum1, lum2);
  return (lighter + 0.05) / (darker + 0.05);
}

function rgbToHex(r, g, b) {
  return "#" + [r, g, b].map(x => {
    const hex = Math.round(x).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");
}

function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return { h: h * 360, s, l };
}

function hslToRgb(h, s, l) {
  h /= 360;
  
  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
  };

  let r, g, b;
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

/* ---------- Beautiful Color System ---------- */
function createBeautifulCombinations(palette) {
  const combinations = [];
  
  // Extract dominant colors and create beautiful dark+light pairs with proper contrast
  palette.forEach(color => {
    const hsl = rgbToHsl(color.r, color.g, color.b);
    
    // Create light background version with guaranteed contrast
    const lightBg = hslToRgb(hsl.h, Math.max(0.05, hsl.s * 0.12), Math.max(0.90, 0.95));
    let darkText = hslToRgb(hsl.h, Math.min(0.80, hsl.s * 1.2), Math.min(0.20, hsl.l * 0.4));
    
    // Ensure minimum 4.5:1 contrast ratio for text
    let contrast = getContrastRatio(lightBg, darkText);
    while (contrast < 4.5 && darkText.r + darkText.g + darkText.b > 30) {
      darkText = hslToRgb(hsl.h, darkText.s, Math.max(0.05, darkText.l * 0.8));
      contrast = getContrastRatio(lightBg, darkText);
    }
    
    const accent = hslToRgb(hsl.h, Math.min(0.85, hsl.s * 1.3), Math.max(0.35, hsl.l * 0.8));
    
    combinations.push({
      bg: rgbToHex(lightBg.r, lightBg.g, lightBg.b),
      text: rgbToHex(darkText.r, darkText.g, darkText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Tinted Light'
    });
    
    // Create dark background version with guaranteed contrast  
    const darkBg = hslToRgb(hsl.h, Math.min(0.6, hsl.s * 0.8), Math.max(0.05, Math.min(0.20, hsl.l * 0.3)));
    let lightText = hslToRgb(hsl.h, Math.max(0.1, hsl.s * 0.3), Math.max(0.85, 0.95));
    
    // Ensure minimum 4.5:1 contrast ratio for light text on dark background
    contrast = getContrastRatio(darkBg, lightText);
    while (contrast < 4.5 && lightText.r + lightText.g + lightText.b < 720) {
      lightText = hslToRgb(hsl.h, Math.max(0.05, lightText.s * 0.9), Math.min(0.98, lightText.l * 1.05));
      contrast = getContrastRatio(darkBg, lightText);
    }
    
    const lightAccent = hslToRgb(hsl.h, Math.max(0.4, hsl.s * 0.9), Math.max(0.65, hsl.l * 1.1));
    
    combinations.push({
      bg: rgbToHex(darkBg.r, darkBg.g, darkBg.b),
      text: rgbToHex(lightText.r, lightText.g, lightText.b),
      accent: rgbToHex(lightAccent.r, lightAccent.g, lightAccent.b),
      name: 'Tinted Dark'
    });
    
    // Create medium light version with contrast check
    const mediumBg = hslToRgb(hsl.h, Math.max(0.08, hsl.s * 0.2), Math.max(0.85, 0.92));
    let mediumText = hslToRgb(hsl.h, Math.min(0.8, hsl.s * 1.2), Math.min(0.25, hsl.l * 0.5));
    
    contrast = getContrastRatio(mediumBg, mediumText);
    while (contrast < 4.5 && mediumText.r + mediumText.g + mediumText.b > 30) {
      mediumText = hslToRgb(hsl.h, mediumText.s, Math.max(0.08, mediumText.l * 0.85));
      contrast = getContrastRatio(mediumBg, mediumText);
    }
    
    combinations.push({
      bg: rgbToHex(mediumBg.r, mediumBg.g, mediumBg.b),
      text: rgbToHex(mediumText.r, mediumText.g, mediumText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Soft Light'
    });
    
    // Create medium dark version with contrast check
    const mediumDarkBg = hslToRgb(hsl.h, Math.min(0.5, hsl.s * 0.7), Math.max(0.15, Math.min(0.30, hsl.l * 0.5)));
    let mediumLightText = hslToRgb(hsl.h, Math.max(0.15, hsl.s * 0.4), Math.max(0.80, 0.90));
    
    contrast = getContrastRatio(mediumDarkBg, mediumLightText);
    while (contrast < 4.5 && mediumLightText.r + mediumLightText.g + mediumLightText.b < 720) {
      mediumLightText = hslToRgb(hsl.h, Math.max(0.05, mediumLightText.s * 0.9), Math.min(0.95, mediumLightText.l * 1.05));
      contrast = getContrastRatio(mediumDarkBg, mediumLightText);
    }
    
    combinations.push({
      bg: rgbToHex(mediumDarkBg.r, mediumDarkBg.g, mediumDarkBg.b),
      text: rgbToHex(mediumLightText.r, mediumLightText.g, mediumLightText.b),
      accent: rgbToHex(lightAccent.r, lightAccent.g, lightAccent.b),
      name: 'Soft Dark'
    });
  });
  
  // Add some classic combinations with white and dark backgrounds using image colors
  palette.slice(0, 3).forEach(color => {
    const hsl = rgbToHsl(color.r, color.g, color.b);
    let darkText = hslToRgb(hsl.h, Math.min(0.8, hsl.s * 1.2), Math.min(0.25, hsl.l * 0.5));
    let lightText = hslToRgb(hsl.h, Math.max(0.1, hsl.s * 0.3), Math.max(0.85, 0.95));
    const accent = hslToRgb(hsl.h, Math.min(0.9, hsl.s * 1.3), Math.max(0.35, hsl.l * 0.8));
    
    // Ensure dark text has proper contrast on white
    const whiteBg = {r: 255, g: 255, b: 255};
    let contrast = getContrastRatio(whiteBg, darkText);
    while (contrast < 4.5 && darkText.r + darkText.g + darkText.b > 30) {
      darkText = hslToRgb(hsl.h, darkText.s, Math.max(0.05, darkText.l * 0.8));
      contrast = getContrastRatio(whiteBg, darkText);
    }
    
    // Light variants
    combinations.push({
      bg: '#ffffff',
      text: rgbToHex(darkText.r, darkText.g, darkText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Clean'
    });
    
    const offWhiteBg = {r: 250, g: 250, b: 250};
    contrast = getContrastRatio(offWhiteBg, darkText);
    while (contrast < 4.5 && darkText.r + darkText.g + darkText.b > 30) {
      darkText = hslToRgb(hsl.h, darkText.s, Math.max(0.05, darkText.l * 0.85));
      contrast = getContrastRatio(offWhiteBg, darkText);
    }
    
    combinations.push({
      bg: '#fafafa',
      text: rgbToHex(darkText.r, darkText.g, darkText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Minimal'
    });
    
    // Ensure light text has proper contrast on dark backgrounds
    const darkBg1 = {r: 26, g: 26, b: 26};
    contrast = getContrastRatio(darkBg1, lightText);
    while (contrast < 4.5 && lightText.r + lightText.g + lightText.b < 720) {
      lightText = hslToRgb(hsl.h, Math.max(0.05, lightText.s * 0.9), Math.min(0.98, lightText.l * 1.05));
      contrast = getContrastRatio(darkBg1, lightText);
    }
    
    // Dark variants
    combinations.push({
      bg: '#1a1a1a',
      text: rgbToHex(lightText.r, lightText.g, lightText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Dark Clean'
    });
    
    const deepDarkBg = {r: 15, g: 15, b: 15};
    contrast = getContrastRatio(deepDarkBg, lightText);
    while (contrast < 4.5 && lightText.r + lightText.g + lightText.b < 720) {
      lightText = hslToRgb(hsl.h, Math.max(0.05, lightText.s * 0.9), Math.min(0.98, lightText.l * 1.02));
      contrast = getContrastRatio(deepDarkBg, lightText);
    }
    
    combinations.push({
      bg: '#0f0f0f',
      text: rgbToHex(lightText.r, lightText.g, lightText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Deep Dark'
    });
  });
  
  return combinations;
}

function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

function resetColorSystem() {
  extractedPalette = [];
  colorCombinations = [];
  document.getElementById('shuffleBtn').disabled = true;
  hideColorPalette();
}

function enhanceColorVibrancy(color) {
  const hsl = rgbToHsl(color.r, color.g, color.b);
  // Increase saturation and adjust lightness for more vibrant accent
  const enhancedHsl = {
    h: hsl.h,
    s: Math.min(0.9, hsl.s * 1.3),
    l: hsl.l > 0.5 ? Math.max(0.3, hsl.l - 0.2) : Math.min(0.7, hsl.l + 0.2)
  };
  return hslToRgb(enhancedHsl.h, enhancedHsl.s, enhancedHsl.l);
}

function shuffleColors() {
  if (colorCombinations.length === 0) return;
  
  currentColorIndex = (currentColorIndex + 1) % colorCombinations.length;
  console.log('Shuffling to combination', currentColorIndex + 1, 'of', colorCombinations.length, ':', colorCombinations[currentColorIndex].name);
  applyColorCombination(currentColorIndex);
}

function applyColorCombination(index) {
  if (!colorCombinations[index]) return;
  
  const combo = colorCombinations[index];
  
  // Update color pickers
  document.getElementById('bgColor').value = combo.bg;
  document.getElementById('textColor').value = combo.text;
  document.getElementById('accentColor').value = combo.accent;
  
  // Apply to canvas
  root.style.setProperty('--bg', combo.bg);
  root.style.setProperty('--ink', combo.text);
  root.style.setProperty('--accent', combo.accent);
}

function displayColorPalette() {
  const paletteEl = document.getElementById('colorPalette');
  paletteEl.style.display = 'block';
  
  let html = '<div style="font-size:11px; margin-bottom:4px;">Extracted Colors:</div>';
  html += '<div class="palette-colors">';
  
  extractedPalette.forEach((color, index) => {
    const hex = rgbToHex(color.r, color.g, color.b);
    html += `<div class="color-swatch" style="background-color: ${hex}" title="${hex}"></div>`;
  });
  
  html += '</div>';
  html += `<div style="font-size:10px; color:#666;">${colorCombinations.length} combinations available</div>`;
  
  paletteEl.innerHTML = html;
}

function hideColorPalette() {
  document.getElementById('colorPalette').style.display = 'none';
}

/* ---------- Helpers ---------- */
function toggle(d){ return d==='row' ? 'col' : 'row'; }

/* Keep preview correct on resize */
window.addEventListener("resize", scaleToPreview);

/* Init */
setFormat(document.getElementById("format").value);
updateBlockList();
render();
</script>
</body>
</html>