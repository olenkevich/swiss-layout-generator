<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Design Layout Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --canvas-w: 1280px; --canvas-h: 720px;
    --gap: 8px; --bg:#fff; --ink:#111; --accent:#111;
    
    /* Typography System - Swiss/German Design Principles */
    --baseline: 8px;
    --type-scale-ratio: 1.618; /* Golden ratio */
    
    /* Font Sizes - Modular Scale */
    --type-logo: 48px;      /* 48px - Strong brand presence */
    --type-header: 64px;    /* 64px - Primary hierarchy */
    --type-lead: 40px;      /* 40px - Secondary hierarchy */
    --type-subheader: 32px; /* 32px - Tertiary hierarchy */
    --type-body: 24px;      /* 24px - Main body text */
    --type-small: 18px;     /* 18px - Supporting text */
    --type-caption: 14px;   /* 14px - Fine print */
    
    /* Line Heights - Optical Corrections */
    --lh-tight: 1.1;        /* For large display text */
    --lh-normal: 1.4;       /* For body text */
    --lh-loose: 1.5;        /* For small text */
    
    /* Letter Spacing - Swiss Precision */
    --ls-tight: -0.02em;    /* Condensed for headers */
    --ls-normal: 0;         /* Natural for body */
    --ls-loose: 0.05em;     /* Expanded for small text */
    
    /* Font Weights - Hierarchy Support */
    --fw-light: 300;
    --fw-regular: 400;
    --fw-medium: 500;
    --fw-bold: 600;
    
    /* Spacing Scale - Mathematical Progression */
    --space-xs: calc(var(--baseline) * 1);   /* 8px - Base unit */
    --space-sm: calc(var(--baseline) * 2);   /* 16px - 2:1 */
    --space-md: calc(var(--baseline) * 3);   /* 24px - 3:1 */
    --space-lg: calc(var(--baseline) * 5);   /* 40px - Fibonacci */
    --space-xl: calc(var(--baseline) * 8);   /* 64px - Fibonacci */
    --space-xxl: calc(var(--baseline) * 13); /* 104px - Fibonacci */
    
    /* Swiss/German Proportional Spacing */
    --space-golden: calc(var(--baseline) * 6.18); /* ~49px - Golden ratio * 8 */
    --space-silver: calc(var(--baseline) * 3.31); /* ~26px - Silver ratio * 8 */
  }

  /* App split: left controls, right preview */
  html, body { height:100%; margin:0; font-family: Helvetica, Arial, sans-serif; }
  .app { height:100%; display:flex; position: relative; }
  
  /* Minimal analog clock */
  .clock {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    border: 1px solid #ddd;
    border-radius: 50%;
    background: white;
    z-index: 10;
  }
  .clock-face {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .clock-hand {
    position: absolute;
    background: #333;
    transform-origin: bottom center;
    left: 50%;
  }
  .hour-hand {
    width: 2px;
    height: 18px;
    top: 12px;
    margin-left: -1px;
  }
  .minute-hand {
    width: 1px;
    height: 24px;
    top: 6px;
    margin-left: -0.5px;
  }
  .clock-center {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 4px;
    height: 4px;
    background: #333;
    border-radius: 50%;
    transform: translate(-50%, -50%);
  }

  /* Left sidebar - Minimal clean */
  .sidebar {
    width: 320px;
    background: #fafafa;
    border-right: 1px solid #ddd;
    padding: 20px;
    box-sizing: border-box;
    display: flex; 
    flex-direction: column; 
    gap: 20px;
  }
  .sidebar h3 { 
    margin: 0 0 12px 0; 
    font-size: 13px;
    font-weight: 600;
    color: #333;
    letter-spacing: 0.5px;
  }
  .sidebar input[type=text], .sidebar select { 
    width: 100%; 
    padding: 10px; 
    box-sizing: border-box;
    border: 1px solid #ddd;
    border-radius: 2px;
    font-size: 14px;
  }
  .sidebar input[type=text]:focus, .sidebar select:focus {
    outline: none;
    border-color: #999;
  }
  .sidebar input[type=file] { 
    width: 100%;
    padding: 8px;
  }
  .sidebar button { 
    padding: 10px 16px; 
    cursor: pointer;
    border: 1px solid #ddd;
    background: white;
    border-radius: 2px;
    font-size: 13px;
    font-weight: 500;
  }
  .sidebar button:hover {
    background: #f5f5f5;
    border-color: #999;
  }
  .sidebar label { 
    display: block; 
    margin: 8px 0; 
    font-size: 12px;
    color: #666;
  }
  .sidebar input[type=color] { 
    width: 40px; 
    height: 32px; 
    margin-left: 8px;
    border: 1px solid #ddd;
    border-radius: 2px;
  }
  
  /* Block list styles - Clean minimal */
  #blockList { 
    max-height: 200px; 
    overflow-y: auto;
    border: 1px solid #eee;
    border-radius: 2px;
  }
  .block-item { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    padding: 8px 12px; 
    margin: 0; 
    background: white; 
    border-bottom: 1px solid #eee; 
    font-size: 12px;
  }
  .block-item:last-child { border-bottom: none; }
  .block-item:hover { background: #f8f8f8; }
  .block-item .block-info { 
    flex: 1; 
    overflow: hidden;
    color: #333;
  }
  .block-item .delete-btn { 
    background: #fff; 
    color: #999; 
    border: 1px solid #ddd;
    padding: 4px 8px; 
    border-radius: 2px; 
    cursor: pointer; 
    font-size: 11px;
    font-weight: 500;
  }
  .block-item .delete-btn:hover {
    background: #f5f5f5;
    color: #666;
    border-color: #999;
  }

  /* Color palette styles */
  #colorPalette { margin: 8px 0; }
  .palette-colors {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin: 4px 0;
  }
  .color-swatch {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid #ddd;
    cursor: pointer;
    transition: transform 0.1s;
  }
  .color-swatch:hover { transform: scale(1.1); }
  
  #shuffleBtn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Right preview panel */
  .preview {
    flex:1;
    position:relative;          /* anchor for absolute #scaler */
    background:#eee;
    overflow:hidden;
    padding: 40px;
    box-sizing: border-box;
  }

  /* Absolutely centered scaler */
  #scaler{
    position:absolute;
    top:50%; left:50%;
    transform-origin: center center; /* scale around center */
  }

  /* Fixed-size canvas (true logical size) */
  #canvas{
    width: var(--canvas-w);
    height: var(--canvas-h);
    background: var(--bg);
    box-shadow: 0 6px 30px rgba(0,0,0,.15);
    padding: var(--gap);
    display:flex;
    overflow:hidden;
  }

  /* Layout engine - Swiss Grid System */
  .row, .col { 
    display: flex; 
    gap: var(--space-sm); /* 16px - optimal content spacing */
    flex: 1 1 0; 
    min-width: 0; 
    min-height: 0; 
  }
  .col { flex-direction: column; }
  .row-reverse { flex-direction: row-reverse; }
  .col-reverse { flex-direction: column-reverse; }
  
  .leaf { 
    flex: 1 1 0; 
    min-width: 0; 
    min-height: 0; 
    padding: var(--space-md); /* 24px - generous content padding */
    overflow: hidden;
    display: flex;
    align-items: flex-end; /* Align to baseline for proper text alignment */
    justify-content: center;
  }
  
  /* Swiss Typography Styles */
  .text { 
    width: 100%; 
    height: auto;
    word-break: keep-all; 
    overflow-wrap: normal; 
    color: var(--ink);
    text-align: left;
    padding-bottom: var(--space-sm); /* 16px consistent baseline offset */
    /* Baseline alignment will be set by fitText function */
  }
  
  .text[data-type="header"] { 
    color: var(--accent);
    font-weight: var(--fw-medium);     /* Medium for headers only */
  }
  
  .text[data-type="subheader"] {
    font-weight: var(--fw-regular);    /* Regular */
  }
  
  .text[data-type="body"] {
    font-weight: var(--fw-regular);    /* Regular */
  }
  
  .text[data-type="logo"] {
    color: var(--accent);
    font-weight: var(--fw-regular);    /* Regular */
    text-transform: uppercase;
    letter-spacing: var(--ls-loose);
  }
  
  .image { 
    width: 100%; 
    height: calc(100% - var(--space-sm)); /* Account for baseline padding */
    object-fit: cover; 
    display: block; 
    padding-bottom: var(--space-sm); /* Same 16px baseline offset as text */
  }
  
  .image.preserve-aspect {
    object-fit: contain;
    height: auto;
    max-height: calc(100% - var(--space-sm));
  }
  
  /* Legacy logo class - updated with Swiss principles */
  .logo { 
    font-weight: var(--fw-medium); 
    font-size: var(--type-logo); 
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: var(--ls-tight);
    padding-bottom: var(--space-sm); /* 16px consistent baseline offset */
  }
</style>
</head>
<body>
<div class="app">
  <!-- Minimal analog clock -->
  <div class="clock">
    <div class="clock-face">
      <div class="clock-hand hour-hand" id="hour-hand"></div>
      <div class="clock-hand minute-hand" id="minute-hand"></div>
      <div class="clock-center"></div>
    </div>
  </div>
  
  <!-- Left controls -->
  <div class="sidebar">
    <!-- AI Generation -->
    <h3>AI Generate</h3>
    <input id="aiPrompt" type="text" placeholder="Describe what you want to create...">
    
    <label style="margin-top: 12px;">Image Style:</label>
    <select id="styleSelect" onchange="handleStyleChange()">
      <option value="b7f1e039-5fb5-47fa-b46e-d886bc87e36c">Style 1</option>
      <option value="402084c3-fbb5-4fe1-8a32-ecdfd3463a39">Style 2</option>
      <option value="72b21ce1-77f0-466e-877a-c3c6bb708e0c">Style 3</option>
      <option value="e85e0f16-e82e-4053-8080-ffd55fa8ecb6">Style 4</option>
      <option value="226190a0-5c43-4e0c-98a0-1a4ba63800cd">Style 5</option>
      <option value="41501ef8-26a6-4d1c-946c-d8b659ff11c3">Style 6</option>
      <option value="custom">Custom Style ID</option>
    </select>
    <input id="customStyleId" type="text" placeholder="Enter custom style ID..." style="display: none; margin-top: 8px;">
    
    <button onclick="generateWithAI()" id="generateBtn" style="background: #007acc; color: white; border: 1px solid #007acc; margin-bottom: 12px;">Generate with AI</button>
    
    <!-- Loading and status indicator -->
    <div id="aiStatus" style="display: none; padding: 8px; background: #f0f8ff; border: 1px solid #b3d9ff; border-radius: 4px; font-size: 12px; color: #0066cc; margin-bottom: 8px;">
      <div id="statusText">Preparing...</div>
      <div id="statusProgress" style="background: #e6f3ff; height: 4px; border-radius: 2px; margin-top: 4px; overflow: hidden;">
        <div id="progressBar" style="height: 100%; background: #007acc; width: 0%; transition: width 0.3s ease;"></div>
      </div>
    </div>
    
    <!-- Error display -->
    <div id="aiError" style="display: none; padding: 8px; background: #fff0f0; border: 1px solid #ffb3b3; border-radius: 4px; font-size: 12px; color: #cc0000; margin-bottom: 8px;">
      <div id="errorText"></div>
      <button onclick="retryGeneration()" id="retryBtn" style="margin-top: 6px; padding: 4px 8px; font-size: 11px; background: white; border: 1px solid #cc0000; color: #cc0000; border-radius: 2px; cursor: pointer;">Retry</button>
    </div>
    
    <h3>Add Text Block</h3>
    <input id="textContent" type="text" placeholder="Enter text content">
    <select id="textType">
      <option value="header">Header</option>
      <option value="subheader">Subheader</option>
      <option value="body">Body Text</option>
      <option value="logo">Logo</option>
    </select>
    <button onclick="addTextBlock()">Add Text</button>

    <h3>Add Image</h3>
    <input id="imageFile" type="file" accept="image/*" onchange="addImageBlock()">
    <label><input id="useImageColors" type="checkbox" checked> Use image colors</label>
    <label><input id="preserveAspect" type="checkbox"> Preserve aspect ratio</label>

    <h3>Current Blocks</h3>
    <div id="blockList"></div>

    <h3>Format</h3>
    <select id="format">
      <option value="16-9" selected>16:9</option>
      <option value="1-1">1:1</option>
      <option value="a4">A4 Portrait</option>
      <option value="a4landscape">A4 Landscape</option>
    </select>

    <h3>Colors</h3>
    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
      <span style="font-size: 12px;">BG:</span>
      <input id="bgColor" type="color" value="#ffffff" onchange="applyColors()" style="width: 32px; height: 28px;">
      <span style="font-size: 12px;">Text:</span>
      <input id="textColor" type="color" value="#111111" onchange="applyColors()" style="width: 32px; height: 28px;">
      <span style="font-size: 12px;">Accent:</span>
      <input id="accentColor" type="color" value="#111111" onchange="applyColors()" style="width: 32px; height: 28px;">
    </div>
    <button onclick="shuffleColors()" id="shuffleBtn" disabled style="padding: 10px; font-size: 14px; width: 100%; margin-bottom: 8px;">Shuffle Colors</button>
    <div id="colorPalette" style="display:none;"></div>

    <h3>Actions</h3>
    <button onclick="render()" style="padding: 16px; font-size: 15px; font-weight: 600; width: 100%; background: #333; color: white; border: 1px solid #333;">Recompose</button>
  </div>

  <!-- Right preview -->
  <div class="preview" id="preview">
    <div id="scaler">
      <div id="canvas"></div>
    </div>
  </div>
</div>

<script>
const root   = document.documentElement;
const canvas = document.getElementById("canvas");
const scaler = document.getElementById("scaler");
const preview= document.getElementById("preview");

let blocks = [
  {id: 'demo-header', type: 'header', content: 'Design Made Simple', hero: true, size: 'large'},
  {id: 'demo-body', type: 'body', content: 'Create stunning layouts with our intelligent design generator. Perfect for presentations, social media, and creative projects.', size: 'large'},
  {id: 'demo-subheader', type: 'subheader', content: 'Professional Results in Seconds', size: 'large'},
  {id: 'demo-logo', type: 'logo', content: 'STUDIO', size: 'large'},
  {id: 'demo-image', type: 'image', src: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgdmlld0JveD0iMCAwIDQwMCAzMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MDAiIGhlaWdodD0iMzAwIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMF8xKSIvPgo8ZGVmcz4KPGXPYW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8wXzEiIHgxPSIwIiB5MT0iMCIgeDI9IjQwMCIgeTI9IjMwMCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjNjY2NkZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGNjZEQSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=', size: 'large'}
];

// Typography Scale - Swiss Design Hierarchy
const SCALE = { 
  header: 64,     // Primary headlines - strong presence
  subheader: 32,  // Secondary headlines - clear hierarchy  
  body: 24,       // Main text - optimal readability
  logo: 48,       // Brand identity - balanced prominence
  lead: 40,       // Introductory text - intermediate hierarchy
  small: 18,      // Supporting text - maintains legibility
  caption: 14     // Fine print - compact but readable
};

// Typography Properties - Swiss/German/Soviet Hierarchy
const TYPE_PROPS = {
  header: { weight: 600, lineHeight: 1.1, letterSpacing: '-0.03em' },     // Bold for impact
  subheader: { weight: 500, lineHeight: 1.2, letterSpacing: '-0.015em' }, // Medium hierarchy
  body: { weight: 400, lineHeight: 1.4, letterSpacing: '0' },             // Regular readability
  logo: { weight: 500, lineHeight: 1.1, letterSpacing: '-0.02em' },       // Medium brand presence
  lead: { weight: 450, lineHeight: 1.3, letterSpacing: '-0.01em' },       // Slightly bold intro
  small: { weight: 400, lineHeight: 1.5, letterSpacing: '0.015em' },      // Regular with space
  caption: { weight: 400, lineHeight: 1.5, letterSpacing: '0.05em' }      // Extended fine print
};

const BASELINE = 8;

let extractedPalette = [];
let colorCombinations = [];
let currentColorIndex = 0;

/* ---------- Controls ---------- */
function addTextBlock(){
  const content = document.getElementById("textContent").value;
  const type = document.getElementById("textType").value;
  
  if(!content.trim()) {
    alert('Please enter some text content');
    return;
  }
  
  const id = (crypto.randomUUID) ? crypto.randomUUID() : ("id-"+Math.random().toString(36).slice(2));
  const block = {
    id, 
    type, 
    content: content.trim(), 
    size: 'large'
  };
  
  if(type === 'header') block.hero = true;
  
  blocks.push(block);
  document.getElementById("textContent").value = '';
  updateBlockList();
  render();
}

function addImageBlock(){
  const file = document.getElementById("imageFile").files[0];
  
  if(!file) {
    return; // No file selected, do nothing
  }
  
  const id = (crypto.randomUUID) ? crypto.randomUUID() : ("id-"+Math.random().toString(36).slice(2));
  const imageSrc = URL.createObjectURL(file);
  const preserveAspect = document.getElementById("preserveAspect").checked;
  
  blocks.push({
    id, 
    type: 'image', 
    src: imageSrc, 
    size: 'large',
    preserveAspect: preserveAspect
  });
  
  updateBlockList();
  render();
  
  // Check if "Use image colors" is enabled
  const useImageColors = document.getElementById("useImageColors").checked;
  
  if (useImageColors) {
    // Extract beautiful color palette from the uploaded image
    extractBeautifulPalette(imageSrc).then(palette => {
      extractedPalette = palette;
      colorCombinations = createBeautifulCombinations(palette);
      currentColorIndex = 0;
      
      console.log('Generated', colorCombinations.length, 'color combinations');
      displayColorPalette();
      if (colorCombinations.length > 0) {
        applyColorCombination(0);
        document.getElementById('shuffleBtn').disabled = false;
      }
    }).catch(err => {
      console.log('Color extraction failed:', err.message);
      resetColorSystem();
    });
  }
}

function deleteBlock(blockId){
  blocks = blocks.filter(b => b.id !== blockId);
  updateBlockList();
  render();
}

function handleStyleChange() {
  const styleSelect = document.getElementById('styleSelect');
  const customStyleInput = document.getElementById('customStyleId');
  
  if (styleSelect.value === 'custom') {
    customStyleInput.style.display = 'block';
  } else {
    customStyleInput.style.display = 'none';
  }
}

// Loading state management functions
function showLoadingState(message, progress = 0) {
  const statusDiv = document.getElementById('aiStatus');
  const statusText = document.getElementById('statusText');
  const progressBar = document.getElementById('progressBar');
  const errorDiv = document.getElementById('aiError');
  
  statusDiv.style.display = 'block';
  errorDiv.style.display = 'none';
  statusText.textContent = message;
  progressBar.style.width = `${progress}%`;
}

function hideLoadingState() {
  const statusDiv = document.getElementById('aiStatus');
  statusDiv.style.display = 'none';
}

function showError(message, canRetry = true) {
  const errorDiv = document.getElementById('aiError');
  const errorText = document.getElementById('errorText');
  const retryBtn = document.getElementById('retryBtn');
  const statusDiv = document.getElementById('aiStatus');
  
  statusDiv.style.display = 'none';
  errorDiv.style.display = 'block';
  errorText.textContent = message;
  retryBtn.style.display = canRetry ? 'inline-block' : 'none';
}

function hideError() {
  const errorDiv = document.getElementById('aiError');
  errorDiv.style.display = 'none';
}

// Store last prompt for retry functionality
let lastGenerationPrompt = '';

function retryGeneration() {
  if (lastGenerationPrompt) {
    document.getElementById('aiPrompt').value = lastGenerationPrompt;
    generateWithAI();
  }
}

function updateBlockList(){
  const listEl = document.getElementById('blockList');
  listEl.innerHTML = '';
  
  blocks.forEach(block => {
    const item = document.createElement('div');
    item.className = 'block-item';
    
    const info = document.createElement('div');
    info.className = 'block-info';
    
    let displayText = '';
    if(block.type === 'image') {
      displayText = `Image (${block.size})`;
    } else {
      const truncated = block.content.length > 20 ? 
        block.content.substring(0, 17) + '...' : 
        block.content;
      displayText = `${block.type}: ${truncated}`;
    }
    
    info.textContent = displayText;
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '×';
    deleteBtn.onclick = () => deleteBlock(block.id);
    
    item.appendChild(info);
    item.appendChild(deleteBtn);
    listEl.appendChild(item);
  });
}

function resetAll(){ 
  blocks = []; 
  updateBlockList(); 
  render(); 
}

/* ---------- Render & Layout ---------- */
function render(){
  canvas.innerHTML = "";
  // Always show the canvas (even if no blocks) so preview is visible
  if(blocks.length===0){
    // empty canvas still scales and centers
    scaleToPreview();
    return;
  }
  
  // Layout direction - content agnostic for true randomization
  let dir;
  if (blocks.length === 2) {
    // Equal chance for both directions regardless of content
    dir = Math.random() < 0.5 ? 'row' : 'col';
  } else {
    // 3+ items use smart direction based on layout aesthetics
    dir = getSmartDirection(blocks);
  }
  
  // Random shuffle - headers can appear anywhere
  const shuffled = [...blocks];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  
  const tree=subdivide(shuffled,dir);
  canvas.appendChild(renderNode(tree));
  requestAnimationFrame(()=>{ 
    scaleToPreview(); 
    // Allow layout to settle before text fitting
    requestAnimationFrame(() => {
      recalcAllText();
      // Double-check after micro-delay for random ratio layouts
      setTimeout(() => recalcAllText(), 10);
    });
  });
}

// Smart direction selection based on content
function getSmartDirection(blocks) {
  const imageCount = blocks.filter(b => b.type === 'image').length;
  const textCount = blocks.filter(b => ['header', 'subheader', 'body'].includes(b.type)).length;
  const hasLogo = blocks.some(b => b.type === 'logo');
  
  // Text-heavy layouts work better in columns (vertical stacking)
  if (textCount > imageCount && textCount > 2) {
    return 'col';
  }
  
  // Image + text combinations work better in rows (horizontal layout)
  if (imageCount >= 1 && textCount >= 1) {
    return 'row';
  }
  
  // Multiple images create gallery-like arrangements in rows
  if (imageCount > 1) {
    return 'row';
  }
  
  // Default to column for simple layouts
  return 'col';
}

// Smart ratio selection based on content importance
function getSmartRatio(items, hasHero) {
  // Swiss/German mathematical ratios
  const GOLDEN = 0.618;      // φ - Golden ratio
  const SILVER = 0.414;      // √2-1 - Silver ratio  
  const PERFECT_FIFTH = 0.6; // 3:5 - Musical harmony
  const FIBONACCI_MAJOR = 0.618; // 8:13 Fibonacci
  const FIBONACCI_MINOR = 0.382; // 5:13 Fibonacci
  
  // Hero content gets prominent space
  if (hasHero) {
    const heroRatios = [GOLDEN, SILVER + 0.2, PERFECT_FIFTH];
    return heroRatios[Math.floor(Math.random() * heroRatios.length)];
  }
  
  // Check content types for intelligent sizing
  const hasImages = items.some(item => item.type === 'image');
  const hasHeaders = items.some(item => item.type === 'header');
  const textItems = items.filter(item => ['header', 'subheader', 'body'].includes(item.type));
  
  // Content-agnostic ratios - equal chance for any content to dominate
  const allRatios = [
    0.5,                    // Equal split
    GOLDEN,                 // 0.618 - Golden ratio
    1 - GOLDEN,             // 0.382 - Inverse golden
    0.67,                   // 2:1 ratio
    0.33,                   // 1:2 ratio  
    PERFECT_FIFTH,          // 0.6 - Musical harmony
    1 - PERFECT_FIFTH,      // 0.4 - Inverse
    SILVER + 0.2,           // 0.614 - Silver variation
    FIBONACCI_MINOR + 0.12  // 0.502 - Near equal
  ];
  
  return allRatios[Math.floor(Math.random() * allRatios.length)];
}

function subdivide(items,dir){
  if(items.length===1) return {kind:"leaf",item:items[0]};
  
  // For 2 items, create more layout variations
  if(items.length === 2) {
    const hero=items.some(it=>it.hero);
    const ratios = hero ? 
      [0.65, 0.7, 0.6, 0.75] : // Hero variations
      [0.5, 0.618, 0.382, 0.55, 0.45, 0.6, 0.4]; // Non-hero variations
    const ratio = ratios[Math.floor(Math.random() * ratios.length)];
    
    // Random ratio assignment - either item can get the larger space
    const flip = Math.random() < 0.5;
    
    return {kind:"split",direction:dir,ratio,
      a:{kind:"leaf",item:items[flip ? 1 : 0]},
      b:{kind:"leaf",item:items[flip ? 0 : 1]}};
  }
  
  // Use standard subdivision for all items
  const hero=items.some(it=>it.hero);
  let ratio=getSmartRatio(items, hero);
  const sizeA=Math.max(1,Math.min(items.length-1,Math.round(items.length*ratio)));
  return {kind:"split",direction:dir,ratio,
    a:subdivide(items.slice(0,sizeA),toggle(dir)),
    b:subdivide(items.slice(sizeA),toggle(dir))};
}

function renderNode(node){
  if(node.kind==="leaf"){
    const el=document.createElement("div"); el.className="leaf";
    if(["header","subheader","body"].includes(node.item.type)){
      const t=document.createElement("div");
      t.className="text"; t.textContent=node.item.content; t.dataset.id=node.item.id;
      t.dataset.type=node.item.type;
      el.appendChild(t);
    }
    if(node.item.type==="image"){
      const img=document.createElement("img"); 
      img.className = node.item.preserveAspect ? "image preserve-aspect" : "image";
      img.src=node.item.src; 
      el.appendChild(img);
    }
    if(node.item.type==="logo"){
      const t=document.createElement("div"); t.className="logo"; t.textContent=node.item.content; el.appendChild(t);
    }
    return el;
  }
  const wrap=document.createElement("div"); wrap.className=node.direction==="row"?"row":"col";
  
  // Simple random ratio assignment
  const flip = Math.random() < 0.5;
  const ratioA = flip ? node.ratio : 1-node.ratio;
  const ratioB = flip ? 1-node.ratio : node.ratio;
  
  const a=document.createElement("div"); a.className=node.direction==="row"?"row":"col"; a.style.flex=ratioA;
  const b=document.createElement("div"); b.className=node.direction==="row"?"row":"col"; b.style.flex=ratioB;
  a.appendChild(renderNode(node.a)); b.appendChild(renderNode(node.b));
  wrap.appendChild(a); wrap.appendChild(b); return wrap;
}

/* ---------- Swiss Typography System ---------- */
function fitText(container, el, item) {
  const maxW = container.offsetWidth;
  const maxH = container.offsetHeight;
  
  // Safety check - if container has no dimensions, skip fitting
  if (maxW <= 0 || maxH <= 0) {
    console.warn('Container has no dimensions, skipping text fitting');
    return;
  }
  
  // Get base size and properties for this type
  let fontSize = SCALE[item.type] || SCALE.body;
  const props = TYPE_PROPS[item.type] || TYPE_PROPS.body;
  
  // Apply Swiss design principles
  const applyTypography = () => {
    el.style.fontSize = fontSize + 'px';
    el.style.fontWeight = props.weight;
    el.style.letterSpacing = props.letterSpacing;
    
    // Calculate line height with baseline grid alignment
    const rawLineHeight = fontSize * props.lineHeight;
    const baselineAlignedHeight = Math.max(
      BASELINE, 
      Math.round(rawLineHeight / BASELINE) * BASELINE
    );
    el.style.lineHeight = baselineAlignedHeight + 'px';
    
    // Swiss/German optical corrections with contextual awareness
    if (fontSize >= 48) {
      // Large display text - aggressive tightening for impact
      el.style.letterSpacing = 'calc(' + props.letterSpacing + ' - 0.02em)';
    } else if (fontSize >= 32) {
      // Medium headers - moderate tightening
      el.style.letterSpacing = 'calc(' + props.letterSpacing + ' - 0.005em)';
    } else if (fontSize <= 18) {
      // Small text - expanded for legibility (Soviet influence)
      el.style.letterSpacing = 'calc(' + props.letterSpacing + ' + 0.025em)';
    }
    
    // Contextual adjustments based on container size
    const containerArea = maxW * maxH;
    if (containerArea < 10000) {
      // Tight spaces - compress slightly more
      el.style.letterSpacing = 'calc(' + el.style.letterSpacing + ' - 0.005em)';
    }
  };
  
  applyTypography();
  
  // Swiss precision - maintain hierarchy while fitting, more flexible for headers
  const isHeader = item.type === 'header';
  const minSize = isHeader ? 
    Math.max(14, fontSize * 0.45) :  // Headers can shrink more but stay readable
    Math.max(12, fontSize * 0.6);   // Other text maintains stricter limits
  let guard = 100;
  
  while (guard-- > 0 && fontSize > minSize) {
    // More precise overflow detection with padding buffer
    const isOverflowing = el.scrollWidth > (maxW - 4) || el.scrollHeight > (maxH - 4);
    if (!isOverflowing) break;
    
    fontSize = Math.max(minSize, fontSize - 1);
    applyTypography();
  }
  
  // Final baseline alignment check
  const computedHeight = parseFloat(el.style.lineHeight);
  if (computedHeight % BASELINE !== 0) {
    el.style.lineHeight = (Math.round(computedHeight / BASELINE) * BASELINE) + 'px';
  }
}
function recalcAllText(){
  canvas.querySelectorAll(".text").forEach(el=>{
    const block=blocks.find(b=>b.id===el.dataset.id);
    if(block) fitText(el.parentElement,el,block);
  });
}

/* ---------- Scaling (uses actual preview pane size) ---------- */
function scaleToPreview(){
  const vw = preview.clientWidth;     // width of the right pane
  const vh = preview.clientHeight;    // height of the right pane
  const cw = canvas.offsetWidth;      // logical canvas size
  const ch = canvas.offsetHeight;
  if(!vw || !vh || !cw || !ch) return;

  // Reserve 40px padding on all sides for scaling calculation
  const availableW = vw - 80;  // 40px on each side
  const availableH = vh - 80;  // 40px on each side
  
  const s = Math.min(availableW / cw, availableH / ch, 1); // only scale down
  scaler.style.width = cw + "px";
  scaler.style.height = ch + "px";
  scaler.style.transform = `translate(-50%, -50%) scale(${s})`;
}

/* ---------- Format chooser ---------- */
function setFormat(fmt){
  let w=1280,h=720;
  if(fmt==="1-1"){w=900;h=900;}
  if(fmt==="a4"){w=794;h=1123;}
  if(fmt==="a4landscape"){w=1123;h=794;}
  root.style.setProperty("--canvas-w", w+"px");
  root.style.setProperty("--canvas-h", h+"px");
  scaleToPreview();
}
document.getElementById("format").addEventListener("change", e=>setFormat(e.target.value));

/* ---------- Color Functions ---------- */
function applyColors() {
  const bg = document.getElementById('bgColor').value;
  const text = document.getElementById('textColor').value;
  const accent = document.getElementById('accentColor').value;
  root.style.setProperty('--bg', bg);
  root.style.setProperty('--ink', text);
  root.style.setProperty('--accent', accent);
}

function autoColors() {
  const firstImage = blocks.find(b => b.type === 'image');
  if (!firstImage) {
    alert('Add an image first to extract colors');
    return;
  }
  
  extractColorsFromImage(firstImage.src).then(colors => {
    const palette = createContrastPalette(colors);
    document.getElementById('bgColor').value = palette.bg;
    document.getElementById('textColor').value = palette.text;
    root.style.setProperty('--bg', palette.bg);
    root.style.setProperty('--ink', palette.text);
  }).catch(err => {
    console.error('Color extraction failed:', err);
    alert('Could not extract colors from image. Try a different image.');
  });
}

function extractBeautifulPalette(imageSrc) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Use good resolution for better color analysis
        const maxSize = 150;
        const scale = Math.min(maxSize / img.width, maxSize / img.height);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const rawColors = [];
        
        // Sample every 16th pixel for good coverage
        for (let i = 0; i < imageData.data.length; i += 64) {
          const r = imageData.data[i];
          const g = imageData.data[i + 1];
          const b = imageData.data[i + 2];
          const a = imageData.data[i + 3];
          
          if (a > 200) { // Only fully opaque pixels
            rawColors.push({r, g, b});
          }
        }
        
        if (rawColors.length === 0) {
          reject(new Error('No colors found in image'));
          return;
        }
        
        const beautifulPalette = createBeautifulPalette(rawColors);
        resolve(beautifulPalette);
        
      } catch (error) {
        reject(error);
      }
    };
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = imageSrc;
  });
}

function createBeautifulPalette(colors) {
  // Group colors by similarity and find the most interesting ones
  const colorClusters = {};
  
  colors.forEach(color => {
    // Group colors into clusters
    const hsl = rgbToHsl(color.r, color.g, color.b);
    const hueGroup = Math.round(hsl.h / 30) * 30; // 30-degree hue groups
    const satGroup = Math.round(hsl.s * 4) / 4; // 0, 0.25, 0.5, 0.75, 1
    const lumGroup = Math.round(hsl.l * 4) / 4; // 0, 0.25, 0.5, 0.75, 1
    
    const key = `${hueGroup}-${satGroup}-${lumGroup}`;
    
    if (!colorClusters[key]) {
      colorClusters[key] = {
        colors: [],
        avgHue: hsl.h,
        avgSat: hsl.s,
        avgLum: hsl.l,
        count: 0
      };
    }
    
    colorClusters[key].colors.push(color);
    colorClusters[key].count++;
  });
  
  // Select the most prominent and interesting colors
  const significantClusters = Object.values(colorClusters)
    .filter(cluster => cluster.count > colors.length * 0.01) // At least 1% of pixels
    .sort((a, b) => {
      // Prefer colorful over gray, and common over rare
      const aInterest = a.avgSat * 2 + (a.count / colors.length);
      const bInterest = b.avgSat * 2 + (b.count / colors.length);
      return bInterest - aInterest;
    })
    .slice(0, 8); // Take top 8 clusters
  
  // Convert back to RGB and create diverse palette
  const palette = [];
  
  significantClusters.forEach(cluster => {
    // Take the most representative color from each cluster
    const representative = cluster.colors.reduce((best, color) => {
      const hsl = rgbToHsl(color.r, color.g, color.b);
      const distance = Math.abs(hsl.h - cluster.avgHue) + 
                      Math.abs(hsl.s - cluster.avgSat) + 
                      Math.abs(hsl.l - cluster.avgLum);
      
      if (!best || distance < best.distance) {
        return {color, distance};
      }
      return best;
    }, null);
    
    if (representative) {
      palette.push(representative.color);
    }
  });
  
  // Ensure we have good variety - add complementary colors if needed
  if (palette.length < 4) {
    palette.push({r: 255, g: 255, b: 255}); // White
    palette.push({r: 50, g: 50, b: 50}); // Dark gray
  }
  
  return palette;
}

function createContrastPalette(colors) {
  return createHarmonicPalette(colors);
}

function createHarmonicPalette(colors) {
  // Get the most prominent colors from the image
  const colorCounts = {};
  colors.forEach(color => {
    const key = `${Math.floor(color.r/30)*30},${Math.floor(color.g/30)*30},${Math.floor(color.b/30)*30}`;
    colorCounts[key] = (colorCounts[key] || 0) + 1;
  });
  
  // Sort by frequency and get top colors
  const sortedColors = Object.entries(colorCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([key, count]) => {
      const [r, g, b] = key.split(',').map(Number);
      return {r, g, b};
    });
  
  // Create beautiful dark+light pairs from extracted colors
  const pairs = [];
  
  sortedColors.forEach(color => {
    const hsl = rgbToHsl(color.r, color.g, color.b);
    
    // Create light version (background)
    const lightBg = hslToRgb(hsl.h, Math.max(0.1, hsl.s * 0.2), Math.max(0.85, 0.95));
    
    // Create dark version (text) 
    const darkText = hslToRgb(hsl.h, Math.min(0.8, hsl.s * 1.2), Math.min(0.25, hsl.l * 0.6));
    
    pairs.push({
      bg: rgbToHex(lightBg.r, lightBg.g, lightBg.b),
      text: rgbToHex(darkText.r, darkText.g, darkText.b)
    });
    
    // Also create inverted pair if the original color works as background
    if (hsl.l > 0.7) {
      const tintedBg = hslToRgb(hsl.h, Math.max(0.15, hsl.s * 0.4), Math.max(0.88, hsl.l));
      pairs.push({
        bg: rgbToHex(tintedBg.r, tintedBg.g, tintedBg.b),
        text: rgbToHex(darkText.r, darkText.g, darkText.b)
      });
    }
  });
  
  // Return a random pair for shuffling
  return pairs[Math.floor(Math.random() * pairs.length)];
}

function getLuminance(r, g, b) {
  const [rs, gs, bs] = [r, g, b].map(c => {
    c = c / 255;
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  });
  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

function getContrastRatio(color1, color2) {
  const lum1 = getLuminance(color1.r, color1.g, color1.b);
  const lum2 = getLuminance(color2.r, color2.g, color2.b);
  const lighter = Math.max(lum1, lum2);
  const darker = Math.min(lum1, lum2);
  return (lighter + 0.05) / (darker + 0.05);
}

function rgbToHex(r, g, b) {
  return "#" + [r, g, b].map(x => {
    const hex = Math.round(x).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");
}

function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return { h: h * 360, s, l };
}

function hslToRgb(h, s, l) {
  h /= 360;
  
  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
  };

  let r, g, b;
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}

/* ---------- Beautiful Color System ---------- */
function createBeautifulCombinations(palette) {
  const combinations = [];
  
  // Extract dominant colors and create beautiful dark+light pairs with proper contrast
  palette.forEach(color => {
    const hsl = rgbToHsl(color.r, color.g, color.b);
    
    // Create light background version with guaranteed contrast
    const lightBg = hslToRgb(hsl.h, Math.max(0.05, hsl.s * 0.12), Math.max(0.90, 0.95));
    let darkText = hslToRgb(hsl.h, Math.min(0.80, hsl.s * 1.2), Math.min(0.20, hsl.l * 0.4));
    
    // Ensure minimum 4.5:1 contrast ratio for text
    let contrast = getContrastRatio(lightBg, darkText);
    while (contrast < 4.5 && darkText.r + darkText.g + darkText.b > 30) {
      darkText = hslToRgb(hsl.h, darkText.s, Math.max(0.05, darkText.l * 0.8));
      contrast = getContrastRatio(lightBg, darkText);
    }
    
    const accent = hslToRgb(hsl.h, Math.min(0.85, hsl.s * 1.3), Math.max(0.35, hsl.l * 0.8));
    
    combinations.push({
      bg: rgbToHex(lightBg.r, lightBg.g, lightBg.b),
      text: rgbToHex(darkText.r, darkText.g, darkText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Tinted Light'
    });
    
    // Create dark background version with guaranteed contrast  
    const darkBg = hslToRgb(hsl.h, Math.min(0.6, hsl.s * 0.8), Math.max(0.05, Math.min(0.20, hsl.l * 0.3)));
    let lightText = hslToRgb(hsl.h, Math.max(0.1, hsl.s * 0.3), Math.max(0.85, 0.95));
    
    // Ensure minimum 4.5:1 contrast ratio for light text on dark background
    contrast = getContrastRatio(darkBg, lightText);
    while (contrast < 4.5 && lightText.r + lightText.g + lightText.b < 720) {
      lightText = hslToRgb(hsl.h, Math.max(0.05, lightText.s * 0.9), Math.min(0.98, lightText.l * 1.05));
      contrast = getContrastRatio(darkBg, lightText);
    }
    
    const lightAccent = hslToRgb(hsl.h, Math.max(0.4, hsl.s * 0.9), Math.max(0.65, hsl.l * 1.1));
    
    combinations.push({
      bg: rgbToHex(darkBg.r, darkBg.g, darkBg.b),
      text: rgbToHex(lightText.r, lightText.g, lightText.b),
      accent: rgbToHex(lightAccent.r, lightAccent.g, lightAccent.b),
      name: 'Tinted Dark'
    });
    
    // Create medium light version with contrast check
    const mediumBg = hslToRgb(hsl.h, Math.max(0.08, hsl.s * 0.2), Math.max(0.85, 0.92));
    let mediumText = hslToRgb(hsl.h, Math.min(0.8, hsl.s * 1.2), Math.min(0.25, hsl.l * 0.5));
    
    contrast = getContrastRatio(mediumBg, mediumText);
    while (contrast < 4.5 && mediumText.r + mediumText.g + mediumText.b > 30) {
      mediumText = hslToRgb(hsl.h, mediumText.s, Math.max(0.08, mediumText.l * 0.85));
      contrast = getContrastRatio(mediumBg, mediumText);
    }
    
    combinations.push({
      bg: rgbToHex(mediumBg.r, mediumBg.g, mediumBg.b),
      text: rgbToHex(mediumText.r, mediumText.g, mediumText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Soft Light'
    });
    
    // Create medium dark version with contrast check
    const mediumDarkBg = hslToRgb(hsl.h, Math.min(0.5, hsl.s * 0.7), Math.max(0.15, Math.min(0.30, hsl.l * 0.5)));
    let mediumLightText = hslToRgb(hsl.h, Math.max(0.15, hsl.s * 0.4), Math.max(0.80, 0.90));
    
    contrast = getContrastRatio(mediumDarkBg, mediumLightText);
    while (contrast < 4.5 && mediumLightText.r + mediumLightText.g + mediumLightText.b < 720) {
      mediumLightText = hslToRgb(hsl.h, Math.max(0.05, mediumLightText.s * 0.9), Math.min(0.95, mediumLightText.l * 1.05));
      contrast = getContrastRatio(mediumDarkBg, mediumLightText);
    }
    
    combinations.push({
      bg: rgbToHex(mediumDarkBg.r, mediumDarkBg.g, mediumDarkBg.b),
      text: rgbToHex(mediumLightText.r, mediumLightText.g, mediumLightText.b),
      accent: rgbToHex(lightAccent.r, lightAccent.g, lightAccent.b),
      name: 'Soft Dark'
    });
  });
  
  // Add some classic combinations with white and dark backgrounds using image colors
  palette.slice(0, 3).forEach(color => {
    const hsl = rgbToHsl(color.r, color.g, color.b);
    let darkText = hslToRgb(hsl.h, Math.min(0.8, hsl.s * 1.2), Math.min(0.25, hsl.l * 0.5));
    let lightText = hslToRgb(hsl.h, Math.max(0.1, hsl.s * 0.3), Math.max(0.85, 0.95));
    const accent = hslToRgb(hsl.h, Math.min(0.9, hsl.s * 1.3), Math.max(0.35, hsl.l * 0.8));
    
    // Ensure dark text has proper contrast on white
    const whiteBg = {r: 255, g: 255, b: 255};
    let contrast = getContrastRatio(whiteBg, darkText);
    while (contrast < 4.5 && darkText.r + darkText.g + darkText.b > 30) {
      darkText = hslToRgb(hsl.h, darkText.s, Math.max(0.05, darkText.l * 0.8));
      contrast = getContrastRatio(whiteBg, darkText);
    }
    
    // Light variants
    combinations.push({
      bg: '#ffffff',
      text: rgbToHex(darkText.r, darkText.g, darkText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Clean'
    });
    
    const offWhiteBg = {r: 250, g: 250, b: 250};
    contrast = getContrastRatio(offWhiteBg, darkText);
    while (contrast < 4.5 && darkText.r + darkText.g + darkText.b > 30) {
      darkText = hslToRgb(hsl.h, darkText.s, Math.max(0.05, darkText.l * 0.85));
      contrast = getContrastRatio(offWhiteBg, darkText);
    }
    
    combinations.push({
      bg: '#fafafa',
      text: rgbToHex(darkText.r, darkText.g, darkText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Minimal'
    });
    
    // Ensure light text has proper contrast on dark backgrounds
    const darkBg1 = {r: 26, g: 26, b: 26};
    contrast = getContrastRatio(darkBg1, lightText);
    while (contrast < 4.5 && lightText.r + lightText.g + lightText.b < 720) {
      lightText = hslToRgb(hsl.h, Math.max(0.05, lightText.s * 0.9), Math.min(0.98, lightText.l * 1.05));
      contrast = getContrastRatio(darkBg1, lightText);
    }
    
    // Dark variants
    combinations.push({
      bg: '#1a1a1a',
      text: rgbToHex(lightText.r, lightText.g, lightText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Dark Clean'
    });
    
    const deepDarkBg = {r: 15, g: 15, b: 15};
    contrast = getContrastRatio(deepDarkBg, lightText);
    while (contrast < 4.5 && lightText.r + lightText.g + lightText.b < 720) {
      lightText = hslToRgb(hsl.h, Math.max(0.05, lightText.s * 0.9), Math.min(0.98, lightText.l * 1.02));
      contrast = getContrastRatio(deepDarkBg, lightText);
    }
    
    combinations.push({
      bg: '#0f0f0f',
      text: rgbToHex(lightText.r, lightText.g, lightText.b),
      accent: rgbToHex(accent.r, accent.g, accent.b),
      name: 'Deep Dark'
    });
  });
  
  return combinations;
}

function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

function resetColorSystem() {
  extractedPalette = [];
  colorCombinations = [];
  document.getElementById('shuffleBtn').disabled = true;
  hideColorPalette();
}

function enhanceColorVibrancy(color) {
  const hsl = rgbToHsl(color.r, color.g, color.b);
  // Increase saturation and adjust lightness for more vibrant accent
  const enhancedHsl = {
    h: hsl.h,
    s: Math.min(0.9, hsl.s * 1.3),
    l: hsl.l > 0.5 ? Math.max(0.3, hsl.l - 0.2) : Math.min(0.7, hsl.l + 0.2)
  };
  return hslToRgb(enhancedHsl.h, enhancedHsl.s, enhancedHsl.l);
}

function shuffleColors() {
  if (colorCombinations.length === 0) return;
  
  currentColorIndex = (currentColorIndex + 1) % colorCombinations.length;
  console.log('Shuffling to combination', currentColorIndex + 1, 'of', colorCombinations.length, ':', colorCombinations[currentColorIndex].name);
  applyColorCombination(currentColorIndex);
}

function applyColorCombination(index) {
  if (!colorCombinations[index]) return;
  
  const combo = colorCombinations[index];
  
  // Update color pickers
  document.getElementById('bgColor').value = combo.bg;
  document.getElementById('textColor').value = combo.text;
  document.getElementById('accentColor').value = combo.accent;
  
  // Apply to canvas
  root.style.setProperty('--bg', combo.bg);
  root.style.setProperty('--ink', combo.text);
  root.style.setProperty('--accent', combo.accent);
}

function displayColorPalette() {
  const paletteEl = document.getElementById('colorPalette');
  paletteEl.style.display = 'block';
  
  let html = '<div style="font-size:11px; margin-bottom:4px;">Extracted Colors:</div>';
  html += '<div class="palette-colors">';
  
  extractedPalette.forEach((color, index) => {
    const hex = rgbToHex(color.r, color.g, color.b);
    html += `<div class="color-swatch" style="background-color: ${hex}" title="${hex}"></div>`;
  });
  
  html += '</div>';
  html += `<div style="font-size:10px; color:#666;">${colorCombinations.length} combinations available</div>`;
  
  paletteEl.innerHTML = html;
}

function hideColorPalette() {
  document.getElementById('colorPalette').style.display = 'none';
}

/* ---------- Helpers ---------- */
function toggle(d){ return d==='row' ? 'col' : 'row'; }

/* Keep preview correct on resize */
window.addEventListener("resize", scaleToPreview);

// Minimal analog clock
function updateClock() {
  const now = new Date();
  const hours = now.getHours() % 12;
  const minutes = now.getMinutes();
  
  const hourAngle = (hours * 30) + (minutes * 0.5); // 30 degrees per hour + minute offset
  const minuteAngle = minutes * 6; // 6 degrees per minute
  
  document.getElementById('hour-hand').style.transform = `translateX(-50%) rotate(${hourAngle}deg)`;
  document.getElementById('minute-hand').style.transform = `translateX(-50%) rotate(${minuteAngle}deg)`;
}

// Update clock every second
setInterval(updateClock, 1000);
updateClock(); // Initial call

// AI Generation Functions
async function generateWithAI() {
  const prompt = document.getElementById('aiPrompt').value.trim();
  if (!prompt) {
    showError('Please enter a description for what you want to create.', false);
    return;
  }
  
  // Store prompt for retry functionality
  lastGenerationPrompt = prompt;
  
  const generateBtn = document.getElementById('generateBtn');
  generateBtn.disabled = true;
  hideError();
  
  try {
    showLoadingState('Preparing generation...', 10);
    
    // Clear existing blocks
    blocks = [];
    updateBlockList();
    
    showLoadingState('Generating text content with AI...', 25);
    
    // Step 1: Generate text content and image prompt with DeepSeek
    let textResponse;
    try {
      textResponse = await generateTextWithDeepSeek(prompt);
      console.log('DeepSeek response:', textResponse);
    } catch (error) {
      console.error('DeepSeek error:', error);
      throw new Error('Failed to generate text content. The AI text service may be unavailable.');
    }
    
    showLoadingState('Processing generated content...', 40);
    
    // Parse the response to extract header, body, and image prompt
    const content = parseAIResponse(textResponse);
    
    if (!content.header && !content.body && !content.subheader) {
      throw new Error('Generated content appears to be empty or invalid. Please try a different prompt.');
    }
    
    showLoadingState('Creating layout elements...', 55);
    
    // Step 2: Add text blocks to layout dynamically
    let blockId = Date.now();
    
    if (content.header) {
      blocks.push({
        id: blockId++,
        type: 'header',
        content: content.header
      });
    }
    
    if (content.subheader) {
      blocks.push({
        id: blockId++,
        type: 'subheader',
        content: content.subheader
      });
    }
    
    if (content.body) {
      blocks.push({
        id: blockId++,
        type: 'body', 
        content: content.body
      });
    }
    
    if (content.caption) {
      blocks.push({
        id: blockId++,
        type: 'body',  // Use body type for captions
        content: content.caption
      });
    }
    
    if (content.logo) {
      blocks.push({
        id: blockId++,
        type: 'logo',
        content: content.logo
      });
    }
    
    showLoadingState('Generating professional advertisement image...', 70);
    
    // Step 3: Generate image with Recraft - use original user prompt for best ad image
    const adImagePrompt = `Create a professional, eye-catching advertisement image for: ${prompt}`;
    
    let imageUrl;
    try {
      imageUrl = await generateImageWithRecraft(adImagePrompt);
    } catch (error) {
      console.error('Image generation error:', error);
      // Don't fail the entire generation if image fails
      console.warn('Continuing without image due to generation error');
    }
    
    showLoadingState('Finalizing layout...', 85);
    
    if (imageUrl) {
      // Add image block
      blocks.push({
        id: Date.now() + 3,
        type: 'image',
        src: imageUrl,
        preserveAspect: false
      });
      
      showLoadingState('Extracting colors from image...', 90);
      
      // Extract colors from the generated image BEFORE rendering
      try {
        await extractColorsFromGeneratedImage(imageUrl);
      } catch (error) {
        console.error('Color extraction failed:', error);
        // Continue without colors if extraction fails
      }
    }
    
    // Update UI and render
    updateBlockList();
    render();
    
    showLoadingState('Complete!', 100);
    setTimeout(() => {
      hideLoadingState();
    }, 1500);
    
  } catch (error) {
    console.error('AI generation error:', error);
    
    // Provide user-friendly error messages based on error type
    let errorMessage = 'An unexpected error occurred. Please try again.';
    
    if (error.message.includes('Failed to generate text content')) {
      errorMessage = 'The AI text service is currently unavailable. Please try again in a moment.';
    } else if (error.message.includes('empty or invalid')) {
      errorMessage = 'The AI couldn\'t generate content for that prompt. Try a more specific description.';
    } else if (error.message.includes('fetch')) {
      errorMessage = 'Network connection error. Please check your internet and try again.';
    } else if (error.message.includes('API error')) {
      errorMessage = 'AI service error. The service may be temporarily unavailable.';
    }
    
    showError(errorMessage, true);
  } finally {
    generateBtn.disabled = false;
    // Don't clear the prompt so user can retry or modify it
  }
}

async function generateTextWithDeepSeek(prompt) {
  try {
    const response = await fetch('/api/generate-text', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ prompt })
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`DeepSeek API error (${response.status}): ${errorData.error || 'Unknown error'}`);
    }
    
    const data = await response.json();
    
    if (!data.content || data.content.trim().length === 0) {
      throw new Error('DeepSeek returned empty content');
    }
    
    return data.content;
  } catch (error) {
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      throw new Error('Network error: Could not connect to text generation service');
    }
    throw error;
  }
}

async function generateImageWithRecraft(imagePrompt) {
  try {
    // Get selected style ID from UI
    const styleSelect = document.getElementById('styleSelect');
    const customStyleInput = document.getElementById('customStyleId');
    
    let styleId = styleSelect.value;
    if (styleId === 'custom' && customStyleInput.value.trim()) {
      styleId = customStyleInput.value.trim();
    }
    
    const response = await fetch('/api/generate-image', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        prompt: imagePrompt,
        styleId: styleId 
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Recraft API error (${response.status}): ${errorData.error || 'Image generation failed'}`);
    }
    
    const data = await response.json();
    
    if (!data.imageUrl) {
      throw new Error('Recraft returned no image URL');
    }
    
    return data.imageUrl;
  } catch (error) {
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      throw new Error('Network error: Could not connect to image generation service');
    }
    console.error('Image generation error:', error);
    throw error;
  }
}

function parseAIResponse(response) {
  const content = {
    header: '',
    subheader: '',
    body: '',
    caption: '',
    logo: '',
    imagePrompt: ''
  };
  
  const lines = response.split('\n');
  
  lines.forEach(line => {
    const trimmedLine = line.trim();
    if (!trimmedLine) return;
    
    if (trimmedLine.startsWith('HEADER:')) {
      content.header = trimmedLine.replace('HEADER:', '').trim();
    } else if (trimmedLine.startsWith('SUBHEADER:')) {
      content.subheader = trimmedLine.replace('SUBHEADER:', '').trim();
    } else if (trimmedLine.startsWith('BODY:')) {
      content.body = trimmedLine.replace('BODY:', '').trim();
    } else if (trimmedLine.startsWith('CAPTION:')) {
      content.caption = trimmedLine.replace('CAPTION:', '').trim();
    } else if (trimmedLine.startsWith('LOGO:')) {
      content.logo = trimmedLine.replace('LOGO:', '').trim();
    } else if (trimmedLine.startsWith('IMAGE:')) {
      content.imagePrompt = trimmedLine.replace('IMAGE:', '').trim();
    }
  });
  
  return content;
}

async function extractColorsFromGeneratedImage(imageUrl) {
  try {
    const colors = await extractColorsFromImage(imageUrl);
    if (colors && colors.length > 0) {
      const palette = createContrastPalette(colors);
      
      // Apply the extracted colors
      document.getElementById('bgColor').value = palette.bg;
      document.getElementById('textColor').value = palette.text;
      if (palette.accent) {
        document.getElementById('accentColor').value = palette.accent;
      }
      
      applyColors();
      
      // Enable shuffle colors button
      document.getElementById('shuffleBtn').disabled = false;
    }
  } catch (error) {
    console.error('Color extraction error:', error);
  }
}

/* Init */
setFormat(document.getElementById("format").value);
updateBlockList();
render();
</script>
</body>
</html>